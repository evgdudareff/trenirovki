// https://contest.yandex.ru/contest/25597/run-report/139571934/

/*
-- ПРИНЦИП РАБОТЫ --
Я написал алгоритм для решения задачи "Одинаковые суммы". По факту алгоритм похож на решение классической задачи
дин. программирования "рюкзак". Только вместо еды у нас числа, а вместо вместительности рюкзака у нас сумма чисел. Причем
мы ищем половину от всей суммы чисел, так как по условию задачи суммы для разбиения должны быть одинаковыми. То есть
задача сводится к поиску подмножества с суммой всех чисел / 2.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Изначально нужно найти полную сумму всех чисел. Если она нечетная, то ответ для задачи будет сразу отрицательный, потому что
нельзя будет разбить числа на две равные группы в этом случае.
Также изначально я решал задачу через двумерный массив dp размером n x m, n - это длина массива чисел + 1 (добавляем туда 0 к числам), а
m - это массив потенциальных сумм от 0 до полусуммы всех чисел. Но такое решение не проходило по памяти, поэтому в итоге
я переписал реешение, чтобы хранились только текущая и предыдущая строки двумерного массива dp (для решения достаточно знать
только предыдущее состояние).
Как и с рюкзаком, на каждом новом числе (итерация по i) мы просчитываем, можем ли мы собрать текущую сумму (j) из
имеющихся на данный момент чисел. Мы либо не берем текущее число (dp[i - 1][j]), если оно больше текущей считаемой суммы,
либо, если число меньше текущей суммы, решаем  - брать или не брать его в набор. Если берём, то нужно итоговая сумма
уменьшается сразу на размер "текущая сумма" - "текущее число", поэтому смотрим на предудыщий набор чисел dp[i - 1][j - numbers[i]].
В итоге в текушую ячейку dp[i][j] положим результат выбора выше (операция ИЛИ).
Есть базовые случаи:
- dp[i][0] == true, поскольку сумма 0 всегда достижима;
- dp[0][j] == false, (j > 0) поскольку нельзя собрать сумму большую 0 из 0;

Ответ будет лежать в dp[n][m], но поскольку массив двумерный и имеет только 2 строки для экономии памяти, то в dp[1][m].

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
В худшем случае нужно просмотреть все строки и все столбцы, то есть O(n x m), где m = sum / 2. Значит O(n x sum/2) = O(n x sum).
Но также добавлена оптимизация на ранний выход, если искомая сумма будет найдена раньше.


-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Храним только 2 строки массива. То есть O(2 x m) = O(m), где m = sum / 2. Значит O(sum/2) = O(sum).
*/

const readline = require('readline');

const ioInterface = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
});
ioInterface.on('line', onLineListener);
ioInterface.on('close', solve);


let n
let numbers = [];
let lineNumber = 0;

function onLineListener(line) {
    if (lineNumber === 0) {
        n = Number(line);
        lineNumber++;
    } else  {
        numbers = line.split(' ').map(Number);
    }
}


function solve() {
    const sum = numbers.reduce((sum, curr) => sum + curr, 0);

    if (sum % 2 !== 0) {
        process.stdout.write('False');
        return;
    }

    const halfSum = sum / 2;
    const dp = [
        new Array(halfSum + 1).fill(false),
        new Array(halfSum + 1).fill(false)
    ];
    let ans;

    for (let i = 0; i <= n; i++) {
        // перезаписываем имеющиеся массивы
        let currI = i % 2;
        let prevI = 1 - currI;

        for (let j = 0; j <= halfSum; j++) {
            if (j === 0) {
                dp[currI][j] = true;
            } else if (i === 0) {
                dp[currI][j] = false;
            } else {
                const isCurrSumGtCurrNum = j >= numbers[i];
                const notIncludeCurrNum = dp[prevI][j];
                const includeCurrNum =  isCurrSumGtCurrNum ? dp[prevI][j - numbers[i]] : false;

                dp[currI][j] = isCurrSumGtCurrNum ? (notIncludeCurrNum || includeCurrNum) : notIncludeCurrNum;
            }
        }

        // ранний выход, если уже достигли искомой суммы
        if (dp[currI][halfSum]) {
            ans = true;
            break
        }
    }

    ans = ans ?? dp[1][halfSum];

    process.stdout.write(`${ans ? 'True' : 'False'}`);
}
