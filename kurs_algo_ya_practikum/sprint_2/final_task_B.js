// https://contest.yandex.ru/contest/22781/run-report/135474551/

/*
-- ПРИНЦИП РАБОТЫ --
Я реализовал калькулятор на принципе польской нотации. Не понимаю, нафига в условии задачи расписано, как её решать.
Не буду копипастить принцип работы полностью, только самое основное:
- на вход подаются цифры и операнды +, -, *, / (деление целочисленное, округление вниз)
- цифры помещаем в стек
- встречаем операнд? вынимаем 2 числа в порядке их добавления из стека, производим операцию, кладём обратно в стек результат
- продолжаем в том же духе, пока ввод не закончится
- в итоге вынимаем из вершины стека число - это и будет ответ (даже если там еще есть числа)

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Ничего не было сказано про какие-то там корнер-кейсы, но видимо тесты построены так, что особо чего-то
изначально неправильного на вход не подаётся.
Как уже было сказано выше, числа кладём в стек. Стек реализован на динамическом массиве. Принцип работы описан выше,
корректность вытекает из неё + адекватные входные данные.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Извлечение из стека - O(1).
С добавлением, в лучшем случае, тоже O(1). Но динамический массив может потребовать реаллокацию,
то есть выделить новый участок памяти и скопировать туда старое содержимое. Это будет стоить O(n). То есть в худшем
случае добавление обойдётся в O(n). Однако есть такое понятие как амортизационная сложность, позволяет оценить сложность,
которая меняется от случая к случаю. В случае с дин. массивом, амортизационная сложность O(n) / n = O(1).
Сама арифметичкая операция - O(1).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Стек построен на динамическом массиве и займёт в худшем случае O(n) памяти.
*/

const readline = require('readline');

const ioInterface = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
});
ioInterface.on('line', onLineListener);
ioInterface.on('close', solve);

const stack = [];
const operatorFuncs = {
    '+': (a, b) => Number(a) + Number(b),
    '-': (a, b) => Number(a) - Number(b),
    '*': (a, b) => Number(a) * Number(b),
    '/': (a, b) => Math.floor(Number(a) / Number(b)),
}

function onLineListener (line) {
    line.split(' ').map((char) => {
        const operatorFunc = operatorFuncs[char];

        if (operatorFunc) {
            const numB = stack.pop();
            const numA = stack.pop();
            const operationResult = operatorFunc(numA, numB);
            stack.push(operationResult);
        } else {
            stack.push(char);
        }
    })
}

function solve() {
    const answer = stack.pop();
    process.stdout.write(String(answer));
}
